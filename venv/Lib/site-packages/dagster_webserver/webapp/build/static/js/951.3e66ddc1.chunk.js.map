{"version":3,"file":"static/js/951.3e66ddc1.chunk.js","mappings":"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","sources":["../../core/src/hooks/useDocumentTitle.tsx","../../ui/src/components/CodeMirror.tsx","../../ui/src/components/configeditor/codemirror-yaml/mode.tsx"],"sourcesContent":["import * as React from 'react';\n\nexport const useDocumentTitle = (title: string) => {\n  React.useEffect(() => {\n    const currentTitle = document.title;\n    document.title = title;\n    return () => {\n      document.title = currentTitle;\n    };\n  }, [title]);\n};\n","import 'codemirror/lib/codemirror.css';\n\nimport * as React from 'react';\nimport {Controlled, UnControlled as Uncontrolled} from 'react-codemirror2';\nimport {createGlobalStyle} from 'styled-components/macro';\n\nimport {Colors} from './Colors';\nimport {Icons} from './Icon';\nimport {registerYaml} from './configeditor/codemirror-yaml/mode';\nimport {FontFamily} from './styles';\n\n// Explicitly register YAML to ensure that the YAML import is bundled correctly.\nregisterYaml();\n\nexport const DagitCodeMirrorStyle = createGlobalStyle`\n  .react-codemirror2 .CodeMirror {\n    font-family: ${FontFamily.monospace};\n    font-size: 16px;\n\n    /* Note: Theme overrides */\n    &.cm-s-default .cm-comment {\n      color: #999;\n    }\n  }\n\n  .CodeMirror-gutter-elt {\n    .CodeMirror-lint-marker-error {\n      background-image: none;\n      background: ${Colors.Red500};\n      mask-image: url(${Icons.error});\n      mask-size: cover;\n      margin-bottom: 2px;\n    }\n  }\n\n  .CodeMirror-hint,\n  .CodeMirror-lint-marker-error,\n  .CodeMirror-lint-marker-warning,\n  .CodeMirror-lint-message-error,\n  .CodeMirror-lint-message-warning {\n    font-family: ${FontFamily.monospace};\n    font-size: 16px;\n  }\n\n  .react-codemirror2 .CodeMirror.cm-s-dagit {\n    .cm-atom {\n      color: ${Colors.Blue700};\n    }\n\n    .cm-comment {\n      color: ${Colors.Gray400};\n    }\n\n    .cm-meta {\n      color: ${Colors.Gray700};\n    }\n\n    .cm-number {\n      color: ${Colors.Red700};\n    }\n\n    .cm-string {\n      color: ${Colors.Green700};\n    }\n\n    .cm-string-2 {\n      color: ${Colors.Olive700};\n    }\n\n    .cm-variable-2 {\n      color: ${Colors.Blue500};\n    }\n\n    .cm-keyword {\n      color: ${Colors.Yellow700};\n    }\n\n    .CodeMirror-selected {\n      background-color: ${Colors.Blue50};\n    }\n\n    .CodeMirror-gutters {\n      background-color: ${Colors.Gray50};\n    }\n\n    .cm-indent {\n      display: inline-block;\n\n      &.cm-zero {\n        box-shadow: -1px 0 0 ${Colors.Green200};\n      }\n\n      &.cm-one {\n        box-shadow: -1px 0 0 ${Colors.Blue100};\n      }\n\n      &.cm-two {\n        box-shadow: -1px 0 0 ${Colors.LightPurple};\n      }\n\n      &.cm-three {\n        box-shadow: -1px 0 0 ${Colors.Red200};\n      }\n\n      &.cm-four {\n        box-shadow: -1px 0 0 ${Colors.Yellow200};\n      }\n\n      &.cm-five {\n        box-shadow: -1px 0 0 ${Colors.Olive200};\n      }\n\n      &.cm-six {\n        box-shadow: -1px 0 0 ${Colors.Gray300};\n      }\n    }\n  }\n\n  div.CodeMirror-lint-tooltip {\n    background: rgba(255, 247, 231, 1);\n    border: 1px solid ${Colors.Gray200};\n  }\n\n  .CodeMirror-lint-message {\n    background: transparent;\n  }\n  .CodeMirror-lint-message.CodeMirror-lint-message-error {\n    background: transparent;\n  }\n\n  /* Ensure that hints aren't vertically cutoff*/\n  .CodeMirror-hint div {\n    max-height: none !important;\n  }\n`;\n\ninterface ThemeProp {\n  theme?: string[];\n}\n\nconst makeThemeString = (theme: string[] = []) => [...theme, 'dagit'].join(' ');\n\nexport const StyledReadOnlyCodeMirror = (\n  props: React.ComponentProps<typeof Uncontrolled> & ThemeProp,\n) => {\n  const {options, theme, ...rest} = props;\n  return (\n    <>\n      <DagitCodeMirrorStyle />\n      <Uncontrolled\n        {...rest}\n        options={{...options, readOnly: true, theme: makeThemeString(theme)}}\n      />\n    </>\n  );\n};\n\nexport const StyledCodeMirror = (props: React.ComponentProps<typeof Controlled> & ThemeProp) => {\n  const {options, theme, ...rest} = props;\n  return (\n    <>\n      <DagitCodeMirrorStyle />\n      <Controlled {...rest} options={{...options, theme: makeThemeString(theme)}} />\n    </>\n  );\n};\n","import * as CodeMirror from 'codemirror';\nimport 'codemirror/addon/hint/show-hint';\nimport 'codemirror/addon/search/search';\nimport 'codemirror/addon/search/searchcursor';\nimport 'codemirror/addon/dialog/dialog';\nimport 'codemirror/addon/dialog/dialog.css';\nimport * as yaml from 'yaml';\n\nimport {\n  ConfigSchema,\n  ConfigSchema_allConfigTypes_CompositeConfigType as CompositeConfigType,\n  ConfigSchema_allConfigTypes_MapConfigType as MapConfigType,\n} from '../types/ConfigSchema';\n\n// Example YAML for testing this parser:\n// https://gist.github.com/bengotow/0b700e7d0367750cb31eaf697f865d70\n\ninterface IParseStateParent {\n  key: string;\n  indent: number;\n  childKeys: string[];\n}\n\nenum ContainerType {\n  Dict = 'dict',\n  List = 'list',\n}\n\ninterface IParseState {\n  trailingSpace: boolean;\n  inlineContainers: ContainerType[];\n  escaped: boolean;\n  inValue: boolean;\n  inBlockLiteral: boolean;\n  inBlockLiteralIndentation: number;\n  parents: IParseStateParent[];\n}\n\n// Helper methods that mutate parser state. These must return new JavaScript objects.\n//\nfunction parentsPoppingItemsDeeperThan(parents: IParseStateParent[], indent: number) {\n  while (parents.length > 0 && parents[parents.length - 1]!.indent >= indent) {\n    parents = parents.slice(0, parents.length - 1);\n  }\n  return parents;\n}\n\nfunction parentsAddingChildKeyToLast(parents: IParseStateParent[], key: string) {\n  if (parents.length === 0) {\n    return [];\n  }\n\n  const immediateParent = parents[parents.length - 1]!;\n  return [\n    ...parents.slice(0, parents.length - 1),\n    {\n      key: immediateParent.key,\n      indent: immediateParent.indent,\n      childKeys: [...immediateParent.childKeys, key],\n    },\n  ];\n}\n\nconst indentMark = (col: number) => {\n  switch (col % 14) {\n    case 0:\n      return 'zero';\n    case 2:\n      return 'one';\n    case 4:\n      return 'two';\n    case 6:\n      return 'three';\n    case 8:\n      return 'four';\n    case 10:\n      return 'five';\n    case 12:\n      return 'six';\n    default:\n      return '';\n  }\n};\n\nfunction parentsAddingChildKeyAtIndent(parents: IParseStateParent[], key: string, indent: number) {\n  parents = parentsPoppingItemsDeeperThan(parents, indent);\n  parents = parentsAddingChildKeyToLast(parents, key);\n  parents = [...parents, {key, indent, childKeys: []}];\n  return parents;\n}\n\nconst Constants = ['true', 'false', 'on', 'off', 'yes', 'no'];\n\nexport const RegExps = {\n  KEYWORD: new RegExp('\\\\b((' + Constants.join(')|(') + '))$', 'i'),\n  DICT_COLON: /^:\\s*/,\n  // eslint-disable-next-line no-useless-escape\n  DICT_KEY: /^\\s*(?:[,\\[\\]{}&*!|>'\"%@`][^\\s'\":]|[^,\\[\\]{}#&*!|>'\"%@`])[^# ,]*?(?=\\s*:)/,\n  // eslint-disable-next-line no-useless-escape\n  QUOTED_STRING: /^('([^']|\\\\.)*'?|\"([^\"\\\\]|\\\\.)*\"?)/,\n  // eslint-disable-next-line no-useless-escape\n  BLOCKSTART_PIPE_OR_ARROW: /^\\s*(\\||\\>)\\s*/,\n  // eslint-disable-next-line no-useless-escape\n  NUMBER: /^\\s*-?[0-9\\.]+(?![0-9\\.]+)$/,\n  // eslint-disable-next-line no-useless-escape\n  VARIABLE: /^\\s*(\\&|\\*)[a-z0-9\\._-]+$/i,\n};\n\nconst defineYamlMode = () => {\n  CodeMirror.defineMode('yaml', () => {\n    return {\n      lineComment: '#',\n      flattenSpans: false,\n      fold: 'indent',\n      startState: (): IParseState => {\n        return {\n          trailingSpace: false,\n          escaped: false,\n          inValue: false,\n          inBlockLiteral: false,\n          inBlockLiteralIndentation: 0,\n          inlineContainers: [],\n          parents: [],\n        };\n      },\n      token: (stream, state: IParseState) => {\n        const ch = stream.peek();\n        const col = stream.column();\n\n        // reset escape, indent and trailing\n        const wasEscaped = state.escaped;\n        const wasTrailingSpace = state.trailingSpace;\n        state.escaped = false;\n        state.trailingSpace = false;\n\n        // indent\n        if (col % 2 === 0 && ch === ' ' && stream.match(/  /)) {\n          state.trailingSpace = true;\n          return `indent ${indentMark(col)}`;\n        }\n\n        // whitespace\n        const trailingSpace = stream.eatSpace();\n        if (trailingSpace) {\n          state.trailingSpace = true;\n        }\n\n        // escape\n        if (ch === '\\\\') {\n          state.escaped = true;\n          stream.next();\n          return null;\n        }\n\n        // comments\n        // either beginning of the line or had whitespace before\n        if (ch === '#' && (stream.sol() || wasTrailingSpace)) {\n          stream.skipToEnd();\n          return 'comment';\n        }\n\n        if (state.inBlockLiteral) {\n          // continuation of a literal string that was started on a previous line\n          if (stream.indentation() > state.inBlockLiteralIndentation) {\n            stream.skipToEnd();\n            return 'string';\n          }\n          state.inBlockLiteralIndentation = 0;\n          state.inBlockLiteral = false;\n        }\n\n        // array list item, value to follow\n        if (stream.match(/-/)) {\n          state.inValue = true;\n          return 'meta';\n        }\n\n        // doc start / end\n        if (stream.sol()) {\n          state.inValue = false;\n          state.parents = [];\n\n          if (stream.match(/---/) || stream.match(/\\.\\.\\./)) {\n            return 'def';\n          }\n        }\n\n        // Handle inline objects and arrays. These can be nested arbitrarily but we\n        // don't currently support them spanning multiple lines.\n        if (stream.match(/^(\\{|\\}|\\[|\\])/)) {\n          if (ch === '{') {\n            state.inlineContainers = [...state.inlineContainers, ContainerType.Dict];\n            state.inValue = false;\n          } else if (ch === '}') {\n            state.inlineContainers = state.inlineContainers.slice(\n              0,\n              state.inlineContainers.length - 1,\n            );\n            state.parents = state.parents.slice(0, state.parents.length - 1);\n            state.inValue = state.inlineContainers.length > 0;\n          } else if (ch === '[') {\n            state.inlineContainers = [...state.inlineContainers, ContainerType.List];\n            state.inValue = true;\n          } else if (ch === ']') {\n            state.inlineContainers = state.inlineContainers.slice(\n              0,\n              state.inlineContainers.length - 1,\n            );\n            state.inValue = state.inlineContainers.length > 0;\n          }\n          state.trailingSpace = false;\n          return 'meta';\n        }\n\n        // Handle inline separators. For dictionaries, we pop from value parsing state back to\n        // key parsing state after a comma and unwind the parent stack.\n        if (state.inlineContainers && !wasEscaped && ch === ',') {\n          const current = state.inlineContainers[state.inlineContainers.length - 1];\n          if (current === ContainerType.Dict) {\n            state.parents = state.parents.slice(0, state.parents.length - 1);\n            state.inValue = false;\n          }\n          stream.next();\n          return 'meta';\n        }\n\n        // A `:` fragment starts value parsing mode if it is not the last character on the line\n        if (stream.match(RegExps.DICT_COLON)) {\n          state.inValue = !stream.eol();\n          return 'meta';\n        }\n\n        // Handle dict key fragments. May be the first element on a line or nested within an inline\n        // (eg: {a: 1, b: 2}). We add the new key to the current `parent` and push a new parent\n        // in case the dict key has subkeys.\n        if (!state.inValue) {\n          const match = stream.match(RegExps.DICT_KEY);\n          if (match) {\n            const key = match[0]!;\n            const keyIndent = stream.pos - key.length;\n            state.parents = parentsAddingChildKeyAtIndent(state.parents, key, keyIndent);\n            return 'atom';\n          }\n        }\n\n        if (state.inValue) {\n          let result = null;\n\n          // Child dicts can start within a value if the user is creating a list, but we don't want to\n          // clasifiy \"my\" as a sub-dict in \"- my:weird:key\". As a balance we require that the colon\n          // be followed by the end-of-line or whitespace.\n          const match = !stream.string.match(/[^\\s]:[^\\s]/)\n            ? stream.match(RegExps.DICT_KEY)\n            : false;\n          if (match) {\n            const key = match[0]!;\n            const keyIndent = stream.pos - key.length;\n            state.inValue = false;\n            state.parents = parentsAddingChildKeyAtIndent(state.parents, key, keyIndent);\n            result = 'atom';\n          }\n\n          if (stream.match(RegExps.BLOCKSTART_PIPE_OR_ARROW)) {\n            state.inBlockLiteralIndentation = stream.indentation();\n            state.inBlockLiteral = true;\n            result = 'meta';\n          }\n\n          if (!result) {\n            // First, read any value that is a quoted string until we reach the end quote.\n            let match = stream.match(RegExps.QUOTED_STRING);\n            if (!match) {\n              // If the value is not a string in quotes, read until a separator (,) or container closing character,\n              // then we'll decide what to do with it.\n              const parentContainer = state.inlineContainers[state.inlineContainers.length - 1];\n              match =\n                parentContainer === ContainerType.List\n                  ? stream.match(/^[^,\\]]+/)\n                  : parentContainer === ContainerType.Dict\n                  ? stream.match(/^[^,\\}]+/)\n                  : stream.match(/^.+$/);\n            }\n            const value = match ? match[0]! : '';\n            if (value.match(RegExps.VARIABLE)) {\n              result = 'variable-2';\n            } else if (value.match(RegExps.NUMBER)) {\n              result = 'number';\n            } else if (value.match(RegExps.KEYWORD)) {\n              result = 'keyword';\n            } else {\n              // \"In YAML, you can write a string without quotes, if it doesn't have a special meaning.\",\n              // so if we can't match the content to any other type and we are inValue, we make it a string.\n              // http://blogs.perl.org/users/tinita/2018/03/strings-in-yaml---to-quote-or-not-to-quote.html\n              result = 'string';\n            }\n          }\n\n          // If after consuming the value and trailing spaces we're at the end of the\n          // line, terminate the value and look for another key on the following line.\n          if (stream.eol() && !state.inBlockLiteral) {\n            state.inValue = false;\n          }\n\n          return result;\n        }\n\n        stream.skipToEnd();\n\n        return null;\n      },\n    };\n  });\n};\n\n// TODO\n// Uniquity of keys\n// add colon\n// add colon and return for composites\n\ntype CodemirrorLocation = {\n  line: number;\n  ch: number;\n};\n\ntype CodemirrorHint = {\n  render: (el: Element, self: any, data: any) => void;\n  text: string;\n  from: CodemirrorLocation;\n  to: CodemirrorLocation;\n};\n\ntype CodemirrorToken = CodeMirror.Token & {\n  state: IParseState;\n};\n\nconst registerYamlHint = () => {\n  CodeMirror.registerHelper(\n    'hint',\n    'yaml',\n    (\n      editor: any,\n      options: {\n        schema?: ConfigSchema;\n      },\n    ): {list: Array<CodemirrorHint>; from: CodemirrorLocation; to: CodemirrorLocation} => {\n      const {\n        cursor,\n        context,\n        token,\n        start,\n        searchString,\n        prevToken,\n      } = expandAutocompletionContextAtCursor(editor);\n\n      const from = {line: cursor.line, ch: start};\n      const to = {line: cursor.line, ch: token.end};\n\n      if (!options.schema) {\n        return {list: [], from, to};\n      }\n\n      if (!context) {\n        return {list: [], from, to};\n      }\n\n      // Since writing meaningful tests for this functionality is difficult given a) no jsdom\n      // support for APIs that codemirror uses (and so no way to use snapshot tests) and b) no\n      // appetite (yet) for writing Selenium tests, we record here the manual tests used to verify\n      // this logic. In what follows, | represents the position of the cursor and -> the transition\n      // on accepting an autocomplete suggestion for `storage: filesystem:\n\n      // st|\n      // ->\n      // storage:\n      //   |\n\n      // storage:|\n      // ->\n      // storage:\n      //   filesystem:\n      //     |\n\n      // storage: |\n      // ->\n      // storage:\n      //   filesystem:\n      //     |\n\n      // storage:  |\n      // ->\n      // storage:\n      //   filesystem:\n      //     |\n\n      // storage:\n      //   |\n      // ->\n      // storage:\n      //   filesystem:\n      //     |\n\n      const isCompOrList = (key: string): boolean => {\n        if (!options.schema) {\n          return false;\n        }\n        // Using a lookup table here seems like a good idea\n        // https://github.com/dagster-io/dagster/issues/1966\n        let type = options.schema.allConfigTypes.find((t) => t.key === key);\n        if (!type) {\n          return false;\n        }\n\n        // If nullable, extract the inner type.\n        if (type.__typename === 'NullableConfigType') {\n          const innerKey = type.typeParamKeys[0];\n          type = options.schema.allConfigTypes.find((t) => t.key === innerKey);\n          if (!type) {\n            return false;\n          }\n        }\n\n        return (\n          type.__typename === 'ArrayConfigType' ||\n          type.__typename === 'CompositeConfigType' ||\n          type.__typename === 'MapConfigType'\n        );\n      };\n\n      const formatReplacement = (\n        field: any,\n        start: any,\n        token: CodemirrorToken,\n        prevToken: CodemirrorToken,\n        inList: boolean,\n      ) => {\n        let replacement = `${field.name}`;\n        let postReplacementIndentation = start;\n\n        const listMarkerPresent = prevToken.string === ' ' || prevToken.string === '-';\n        if (inList && !listMarkerPresent) {\n          replacement = `- ${replacement}`;\n          postReplacementIndentation += 2;\n        }\n\n        const cursorAtColon = token.string.startsWith(':');\n        if (cursorAtColon) {\n          const nextLineIndent = prevToken.start + 2;\n          replacement = `\\n${' '.repeat(nextLineIndent)}${replacement}`;\n          postReplacementIndentation = nextLineIndent;\n        }\n\n        const completionHasChildren = isCompOrList(field.configTypeKey);\n        if (completionHasChildren) {\n          replacement += `:\\n${' '.repeat(postReplacementIndentation + 2)}`;\n        } else {\n          replacement += ': ';\n        }\n\n        return replacement;\n      };\n\n      const buildSuggestion = (\n        display: string,\n        replacement: string,\n        description: string | null,\n      ): CodemirrorHint => ({\n        text: replacement,\n        render: (el) => {\n          const div = document.createElement('div');\n          div.textContent = display;\n          if (description) {\n            const docs = document.createElement('div');\n            docs.innerText =\n              description.length < 90 ? description : description.substr(0, 87) + '...';\n            docs.style.opacity = '0.5';\n            docs.style.overflow = 'hidden';\n            docs.style.maxHeight = '33px';\n            docs.style.maxWidth = '360px';\n            docs.style.whiteSpace = 'normal';\n            div.appendChild(docs);\n          }\n          el.appendChild(div);\n        },\n        from,\n        to,\n      });\n\n      // Calculate if this is on a new-line child of a scalar union type, as an indication that we\n      // should autocomplete the selector fields of the scalar union\n      const isScalarUnionNewLine =\n        context.type.__typename === 'ScalarUnionConfigType' && !prevToken.end;\n\n      // The context will have available fields if the type is a composite config type OR a scalar\n      // union type\n      if (\n        context.availableFields.length &&\n        (context.type.__typename === 'CompositeConfigType' || isScalarUnionNewLine)\n      ) {\n        return {\n          list: context.availableFields\n            .filter((field) => field.name.startsWith(searchString))\n            .map((field) =>\n              buildSuggestion(\n                field.name,\n                formatReplacement(field, start, token, prevToken, context.inArray),\n                field.description,\n              ),\n            ),\n          from,\n          to,\n        };\n      }\n\n      // Completion of enum field values\n      if (context.type.__typename === 'EnumConfigType') {\n        const searchWithoutQuotes = searchString.startsWith('\"')\n          ? searchString.substr(1)\n          : searchString;\n        return {\n          list: context.type.values\n            .filter((val) => val.value.startsWith(searchWithoutQuotes))\n            .map((val) => buildSuggestion(val.value, `\"${val.value}\"`, null)),\n          from,\n          to,\n        };\n      }\n\n      // Completion of boolean field values\n      if (context.type.__typename === 'RegularConfigType' && context.type.givenName === 'Bool') {\n        return {\n          list: ['True', 'False']\n            .filter((val) => val.startsWith(searchString))\n            .map((val) => buildSuggestion(val, val, null)),\n          from,\n          to,\n        };\n      }\n\n      // Completion of Scalar Union field values, the union of the scalar suggestions and the\n      // non-scalar suggestions\n      const type = context.type;\n      if (type.__typename === 'ScalarUnionConfigType') {\n        const scalarType = options.schema.allConfigTypes.find((x) => x.key === type.scalarTypeKey);\n        const nonScalarType = options.schema.allConfigTypes.find(\n          (x) => x.key === type.nonScalarTypeKey,\n        );\n        let scalarSuggestions: CodemirrorHint[] = [];\n        if (\n          scalarType &&\n          scalarType.__typename === 'RegularConfigType' &&\n          scalarType.givenName === 'Bool'\n        ) {\n          scalarSuggestions = ['True', 'False']\n            .filter((val) => val.startsWith(searchString))\n            .map((val) => buildSuggestion(val, val, null));\n        }\n        let nonScalarSuggestions: CodemirrorHint[] = [];\n        if (nonScalarType && nonScalarType.__typename === 'CompositeConfigType') {\n          nonScalarSuggestions = nonScalarType.fields\n            .filter((field) => field.name.startsWith(searchString))\n            .map((field) =>\n              buildSuggestion(\n                field.name,\n                formatReplacement(field, start, token, prevToken, false),\n                field.description,\n              ),\n            );\n        }\n\n        return {list: [...scalarSuggestions, ...nonScalarSuggestions], from, to};\n      }\n\n      return {list: [], from, to};\n    },\n  );\n};\n\n/** Takes the pipeline schema and the YAML tokenizer state and returns the\n * type in scope and available (yet-to-be-used) fields\n * if it is a composite type.\n */\nfunction findAutocompletionContext(\n  schema: ConfigSchema | null,\n  parents: IParseStateParent[],\n  currentIndent: number,\n) {\n  parents = parents.filter(({indent}) => currentIndent > indent);\n  const immediateParent = parents[parents.length - 1];\n\n  if (!schema) {\n    // Schema may still be loading\n    return;\n  }\n\n  // We only provide autocompletion if the root type is a Map or a composite (Shape)\n  let type = schema.allConfigTypes.find((t) => t.key === schema.rootConfigType.key);\n  if (!type || (type.__typename !== 'CompositeConfigType' && type.__typename !== 'MapConfigType')) {\n    return null;\n  }\n\n  let available = type.__typename === 'CompositeConfigType' ? type.fields : [];\n\n  // Tracks the nearest mapping type (Shape, Map, etc.) in the hierarchy to the cursor\n  // This is what's rendered in the schema sidebar\n  let closestMappingType: MapConfigType | CompositeConfigType = type;\n  let inArray = false;\n\n  // Tracks the type key to be used for the next depth level\n  // Used for Map config types, which specify the type key for their values, otherwise is null\n  let nextTypeKey: string | null =\n    type.__typename === 'MapConfigType' ? type.typeParamKeys[1]! : null;\n\n  if ((available || type.__typename === 'MapConfigType') && parents.length > 0) {\n    for (const parent of parents) {\n      // In order to provide completion, we must either have type information on hand (parentTypeDef)\n      // for the current key that we are in, or we must have the type info provided by an enclosing Map (nextTypeKey)\n      const parentTypeDef = available.find(({name}) => parent.key === name);\n      if (!parentTypeDef && !nextTypeKey) {\n        return null;\n      }\n\n      // The current composite type's available \"fields\" each only have a configType key.\n      // The rest of the configType's information is in the top level schema.allConfigTypes\n      // to avoid superlinear GraphQL response size.\n      const typeKey = nextTypeKey ? nextTypeKey : parentTypeDef?.configTypeKey;\n      nextTypeKey = null;\n\n      let parentConfigType = schema.allConfigTypes.find((t) => t.key === typeKey)!;\n\n      // If nullable, extract the inner type.\n      if (parentConfigType.__typename === 'NullableConfigType') {\n        const innerType = parentConfigType.typeParamKeys[0];\n        parentConfigType = schema.allConfigTypes.find((t) => t.key === innerType)!;\n      }\n\n      let childTypeKey = parentConfigType.key;\n      let childEntriesUnique = true;\n\n      inArray = parentConfigType.__typename === 'ArrayConfigType';\n      if (inArray) {\n        childTypeKey = parentConfigType.typeParamKeys[0]!;\n        childEntriesUnique = false;\n      }\n\n      // Maps provide no direct autocompletions, but they do act as the closestMappingType,\n      // meaning they show up in the schema sidebar\n      if (parentConfigType.__typename === 'MapConfigType') {\n        nextTypeKey = parentConfigType.typeParamKeys[1]!;\n        closestMappingType = parentConfigType;\n        available = [];\n        continue;\n      }\n\n      type = schema.allConfigTypes.find((t) => t.key === childTypeKey);\n      if (!type) {\n        return null;\n      }\n\n      if (type.__typename === 'ScalarUnionConfigType') {\n        available = [];\n        const nonScalarTypeKey = type.nonScalarTypeKey;\n        const nonScalarType = schema.allConfigTypes.find((x) => x.key === nonScalarTypeKey);\n        if (nonScalarType && nonScalarType.__typename === 'CompositeConfigType') {\n          available = nonScalarType.fields;\n        }\n      } else if (type.__typename === 'CompositeConfigType') {\n        closestMappingType = type;\n        available = type.fields;\n\n        if (parent === immediateParent && childEntriesUnique) {\n          available = available.filter(\n            (item) => immediateParent.childKeys.indexOf(item.name) === -1,\n          );\n        }\n      } else {\n        available = [];\n      }\n    }\n  }\n\n  return {type, closestMappingType, availableFields: available, inArray};\n}\n\n// Find context for a fully- or partially- typed key or value in the YAML document\nexport function expandAutocompletionContextAtCursor(editor: any) {\n  const schema: ConfigSchema = editor.options.hintOptions.schema;\n\n  const cursor = editor.getCursor();\n  const token: CodemirrorToken = editor.getTokenAt(cursor);\n  const prevToken: CodemirrorToken = editor.getTokenAt({\n    line: cursor.line,\n    ch: token.start,\n  });\n\n  let searchString: string;\n  let start: number;\n  if (\n    token.type === 'whitespace' ||\n    token.type?.startsWith('indent ') ||\n    token.string.startsWith(':')\n  ) {\n    searchString = '';\n    start = token.end;\n  } else {\n    searchString = token.string;\n    start = token.start;\n  }\n\n  // Takes the schema and the YAML tokenizer state and returns the\n  // type in scope and available (yet-to-be-used) fields\n  // if it is a composite type.\n  return {\n    start,\n    cursor,\n    searchString,\n    token,\n    prevToken,\n    context: findAutocompletionContext(schema, token.state.parents, start),\n  };\n}\n\ntype CodemirrorLintError = {\n  message: string;\n  severity: 'error' | 'warning' | 'information' | 'hint';\n  type: 'validation' | 'syntax' | 'deprecation';\n  from: CodemirrorLocation;\n  to: CodemirrorLocation;\n};\n\nexport type YamlModeValidationResult =\n  | {\n      isValid: true;\n    }\n  | {\n      isValid: false;\n      errors: YamlModeValidationError[];\n    };\n\nexport type YamlModeValidateFunction = (configYaml: string) => Promise<YamlModeValidationResult>;\n\ntype YamlModeValidationError = {\n  message: string;\n  path: string[];\n  reason: string;\n};\n\nCodeMirror.registerHelper('dagster-docs', 'yaml', (editor: any, pos: CodeMirror.Position) => {\n  const token = editor.getTokenAt(pos);\n\n  const schema: ConfigSchema = editor.options.hintOptions.schema;\n\n  if (token.type !== 'atom') {\n    return null;\n  }\n\n  const context = findAutocompletionContext(schema, token.state.parents, token.start);\n  const match =\n    context &&\n    context.type.__typename === 'CompositeConfigType' &&\n    context.type.fields.find((f) => f.name === token.string);\n\n  if (match && match.description) {\n    return match.description;\n  }\n\n  return null;\n});\n\nconst registerYamlLint = () => {\n  CodeMirror.registerHelper(\n    'lint',\n    'yaml',\n    async (\n      text: string,\n      {checkConfig}: {checkConfig: YamlModeValidateFunction},\n      editor: any,\n    ): Promise<Array<CodemirrorLintError>> => {\n      const codeMirrorDoc = editor.getDoc();\n\n      // TODO: In some scenarios where every line yields an error `parseDocument` can take 1s+\n      // and returns 20,000+ errors. The library does not have a \"bail out\" option but we need one.\n      // However we can't switch libraries because we need the structured document model this returns.\n      // (It's not just text parsed to plain JS objects.)\n      const yamlDoc = yaml.parseDocument(text);\n      const lints: Array<CodemirrorLintError> = [];\n      const lintingTruncated = yamlDoc.errors.length > 10;\n      let lastMarkLocation: CodeMirror.Position | undefined;\n\n      yamlDoc.errors.slice(0, 10).forEach((error) => {\n        const [fromPos, toPos] = error.pos;\n        const from = codeMirrorDoc.posFromIndex(fromPos) as CodeMirror.Position;\n        const to = codeMirrorDoc.posFromIndex(toPos) as CodeMirror.Position;\n\n        if (!lastMarkLocation || lastMarkLocation.line < from.line) {\n          lastMarkLocation = from;\n        }\n\n        lints.push({\n          message: error.message,\n          severity: 'error',\n          type: 'syntax',\n          from,\n          to,\n        });\n      });\n\n      if (lintingTruncated && lastMarkLocation) {\n        const nextLineLocation: CodeMirror.Position = {\n          line: lastMarkLocation.line + 1,\n          ch: 0,\n        };\n        lints.push({\n          message: `${yamlDoc.errors.length - lints.length} more errors - bailed out.`,\n          severity: 'warning',\n          type: 'syntax',\n          from: nextLineLocation,\n          to: nextLineLocation,\n        });\n      }\n\n      if (yamlDoc.errors.length === 0) {\n        const validationResult = await checkConfig(text);\n        if (!validationResult.isValid) {\n          validationResult.errors.forEach((error) => {\n            const lint = validationErrorToCodemirrorError(error, yamlDoc, codeMirrorDoc);\n            if (lint) {\n              lints.push(lint);\n            }\n          });\n        }\n      }\n\n      return lints;\n    },\n  );\n};\n\nfunction validationErrorToCodemirrorError(\n  error: YamlModeValidationError,\n  yamlDoc: yaml.Document,\n  codeMirrorDoc: any,\n): CodemirrorLintError | null {\n  const part = error.reason === 'RUNTIME_TYPE_MISMATCH' ? 'value' : 'key';\n  const range = findRangeInDocumentFromPath(yamlDoc, error.path, part);\n  if (range === null) {\n    return null;\n  }\n  return {\n    message: error.message,\n    severity: 'error',\n    type: 'syntax',\n    from: codeMirrorDoc.posFromIndex(range ? range.start : 0) as CodeMirror.Position,\n    to: codeMirrorDoc.posFromIndex(\n      range ? range.end : Number.MAX_SAFE_INTEGER,\n    ) as CodeMirror.Position,\n  };\n}\n\nexport function findRangeInDocumentFromPath(\n  doc: yaml.Document,\n  path: Array<string>,\n  pathPart: 'key' | 'value',\n): {start: number; end: number} | null {\n  let node = nodeAtPath(doc, path);\n  if (!node || !('type' in node)) {\n    return null;\n  }\n\n  if (node.type === 'PAIR') {\n    if (pathPart === 'value' && node.value) {\n      node = node.value;\n    } else {\n      node = node.key;\n    }\n  }\n\n  if (node && node.range) {\n    return {\n      start: node.range[0],\n      end: node.range[1],\n    };\n  } else {\n    return null;\n  }\n}\n\nfunction nodeAtPath(doc: yaml.Document, path: Array<string>) {\n  let node: any = doc.contents;\n  for (let i = 0; i < path.length; i++) {\n    const part = path[i]!;\n    if (node && node.type && node.type === 'PAIR') {\n      node = node.value;\n    }\n\n    if (node && node.type && (node.type === 'SEQ' || node.type === 'FLOW_SEQ')) {\n      const index = Number.parseInt(part);\n      if (!Number.isNaN(index)) {\n        node = node.items[index];\n      } else {\n        return null;\n      }\n    } else if (node && node.type && (node.type === 'FLOW_MAP' || node.type === 'MAP')) {\n      const item = node.items.find(({key}: {key: any}) => key.value === part);\n      if (item && item.type && item.type === 'PAIR') {\n        node = item;\n      } else {\n        return null;\n      }\n    } else {\n      return null;\n    }\n  }\n\n  return node;\n}\n\nexport const registerYaml = () => {\n  defineYamlMode();\n  registerYamlHint();\n  registerYamlLint();\n};\n"],"names":["useDocumentTitle","title","React","currentTitle","document","registerYaml","DagitCodeMirrorStyle","createGlobalStyle","FontFamily","Colors","Icons","makeThemeString","theme","arguments","length","undefined","concat","_toConsumableArray","join","StyledReadOnlyCodeMirror","props","options","rest","_objectWithoutProperties","_excluded","_jsxs","_Fragment","children","_jsx","Uncontrolled","_objectSpread","readOnly","StyledCodeMirror","_excluded2","Controlled","ContainerType","parentsAddingChildKeyAtIndent","parents","key","indent","slice","parentsPoppingItemsDeeperThan","immediateParent","childKeys","parentsAddingChildKeyToLast","RegExps","KEYWORD","RegExp","DICT_COLON","DICT_KEY","QUOTED_STRING","BLOCKSTART_PIPE_OR_ARROW","NUMBER","VARIABLE","registerYamlHint","CodeMirror","editor","_expandAutocompletion","expandAutocompletionContextAtCursor","cursor","context","token","start","searchString","prevToken","from","line","ch","to","end","schema","list","formatReplacement","field","inList","replacement","name","postReplacementIndentation","listMarkerPresent","string","startsWith","nextLineIndent","repeat","completionHasChildren","type","allConfigTypes","find","t","__typename","innerKey","typeParamKeys","isCompOrList","configTypeKey","buildSuggestion","display","description","text","render","el","div","createElement","textContent","docs","innerText","substr","style","opacity","overflow","maxHeight","maxWidth","whiteSpace","appendChild","isScalarUnionNewLine","availableFields","filter","map","inArray","searchWithoutQuotes","values","val","value","givenName","scalarType","x","scalarTypeKey","nonScalarType","nonScalarTypeKey","scalarSuggestions","nonScalarSuggestions","fields","findAutocompletionContext","currentIndent","_ref","rootConfigType","available","closestMappingType","nextTypeKey","_step","_iterator","_createForOfIteratorHelper","_loop","parent","parentTypeDef","_ref2","v","typeKey","parentConfigType","innerType","childTypeKey","childEntriesUnique","item","indexOf","s","n","done","_ret","err","e","f","_token$type","hintOptions","getCursor","getTokenAt","state","pos","match","validationErrorToCodemirrorError","error","yamlDoc","codeMirrorDoc","part","reason","range","findRangeInDocumentFromPath","path","message","severity","posFromIndex","Number","MAX_SAFE_INTEGER","doc","pathPart","node","contents","_loop2","i","index","parseInt","isNaN","items","_ref5","_ret2","nodeAtPath","lineComment","flattenSpans","fold","startState","trailingSpace","escaped","inValue","inBlockLiteral","inBlockLiteralIndentation","inlineContainers","stream","peek","col","column","wasEscaped","wasTrailingSpace","indentMark","eatSpace","next","sol","skipToEnd","indentation","Dict","List","eol","keyIndent","result","parentContainer","_ref4","_asyncToGenerator","_regeneratorRuntime","mark","_callee","_ref3","checkConfig","lints","lintingTruncated","lastMarkLocation","nextLineLocation","validationResult","wrap","_context","prev","getDoc","yaml","errors","forEach","_error$pos","_slicedToArray","fromPos","toPos","push","sent","isValid","lint","abrupt","stop","_x","_x2","_x3","apply"],"sourceRoot":""}